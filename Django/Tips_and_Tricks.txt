1. Когда приходится иметь дело с несколькими средами, требующими разных конфигураций, то следует создавать настроечный файл отдельно для каждой среды.
2. Индексное упорядочивание в MySQL не поддерживается. Если в  качестве базы данных вы используете MySQL, то убывающий индекс будет создаваться как обычный индекс
3. На практике неплохая идея – определять варианты внутри модельного класса и использовать перечисляемые типы. Такой подход будет позволять легко ссылаться на метки вариантов, значения или имена из любого места исходного кода
4. Вносимые в модельных объект изменения не сохраняются в базе данных до тех пор, пока не применён метод save().
5. Создание файла urls.py для каждого приложения - это хороший стиль программирования и наилучший способ сделать ваши приложения пригодными для реиспользования в других проектах.
6. Для формирования URL-адреов в своих шаблонах всегда следует использовать шаблонный тег {% url %}, а не писать жёстко привязанные URL-адреса.
Такой подход упростит техническое сопровождение URL-адресов в будущем.
7. Для хранения значений денежных сумм всегда следует использовать DecimalField. Используя данный тип, вы избежите проблем с округлением чисел с плавающей запятой.
8. Во избежание межсайтового скриптинга XSS(Cross-Site Scripting) следует избегать использования функции mark_safe с входными данными, получаемыми от пользователя.
XSS позволяет злоумышленникам внедрять скрипты на стороне клиента в веб-контент, просматриваемый другими пользователями.
8. Асинхронные задания следует использовать не только для времязатратных процессов, но и для други процессов, исполнение которых не занимает так много времени, но которые подвержены собям соединения либо требуют политики повторных
попыток соединения.
9. Запросы с операциями поиска в полях формируются с использованием двух знаков подчёркивания, например publish__year, но те же
обозначения также используются для обращения к полям ассоциированных моделей, например author__username.
10. Порядок следования классов фреймворка промежуточных программных компонентов очень важен, потому что каждый промежуточный компонент может зависеть от данных, потому что каждый
промежуточный компонент может зависеть от данных, устанавливаемых другим промежуточным компонентом, который был исполнен ранее. Промежуточный компонент применяется для запросов в порядке их появления в
настроечном параметре MIDDLEWARE и для ответов в обратном порядке.
11. Использование gettext_lazy() вместо gettext() означает, что строковые литералы переводятся при доступе к значению. Django предлагает ленивую версию всех переводных функций.
12. Следует использовать тег {% blocktrans %} вместо тега {% trans %}, когда в переводной строковый литерал нужно вставлять переменных контент.
13. Если при добавлении новых переводов в производственную среду вы раздаёте Django с реальным веб-сервером, то для того, чтобы любые изменения вступали в силу, вам придётся перезагружать сервер после выполнения команды compilemessages либо
после сохранения переводов с помощью приложения Rosetta.
14. Вспомогательная функция static() подходит для разработки, но не для использования в производстве. Django очень неэффективен при раздаче статических файлов. Никогда не следует раздавать статические файлы с помощью Django в производственной среде.
