Алгоритм двух указателей - это один из наиболее простых и эффективных методов, который обычно используется для поиска пар в остортированном массиве.
Рассмотрим эффективность данного алгоритма в этой задаче:
Учитывая отсортированный массив A (отсортированный в порядке возрастания), содержащий N целых чисел, найдите, существует ли какая-либо пара элементов (A[i], A [j]), такая, что их сумма равна X.
Пример без применения данного алгоритма:
# Naive solution to find if there is a
# pair in A[0..N-1] with given sum.
def isPairSum(A, N, X):

    for i in range(N):
        for j in range(N):

            # as equal i and j means same element
            if(i == j):
                continue

            # pair exists
            if (A[i] + A[j] == X):
                return True

            # as the array is sorted
            if (A[i] + A[j] > X):
                break

    # No pair found with given sum
    return 0

# Driver code
arr = [3, 5, 9, 2, 8, 10, 11]
val = 17

print(isPairSum(arr, len(arr), val))
Временная сложность такого алгоритма O(n^2)
Теперь рассмотрим метод решения с помощью двух указателей:
Сначала мы берём два указателя, один из которых указывает на первый элемент списка, а другой на последний элемент.
Если сумма этих элементов меньше X, то мы сдвигаем левый указатель вправо, или если их сумма больше X, то мы сдвигаем правый указатель влево, чтобы приблизиться к сумме.
Мы продолждаем перемещать указатели, пока не получим сумму в виде X.
# Two pointer technique based solution to find
# if there is a pair in A[0..N-1] with a given sum.
def isPairSum(A, N, X):

    # represents first pointer
    i = 0

    # represents second pointer
    j = N - 1

    while(i < j):

        # If we find a pair
        if (A[i] + A[j] == X):
            return True

        # If sum of elements at current
        # pointers is less, we move towards
        # higher values by doing i += 1
        elif(A[i] + A[j] < X):
            i += 1

        # If sum of elements at current
        # pointers is more, we move towards
        # lower values by doing j -= 1
        else:
            j -= 1
    return 0

# array declaration
arr = [3, 5, 9, 2, 8, 10, 11]

# value to search
val = 17

print(isPairSum(arr, len(arr), val))
Временная сложность данного алгоритма: O(n)
Алоритм в основном реализует тот факт, что входной массив отсортирован. Мы начинаем с суммы экстремальных значений(наибольшего и наименьшего) и условно перемещаем оба указателя.
Мы перемещаем левый указатель когда сумма левого и правого элементов меньше X. Мы не пропускаем ни одной пары, потому что сумма уже меньше X.
Та же логика применима для правого указателя j.
Данный алгоритм следует использовать в следующих случаях:
- в задаче упоминается отсортированный массив(или другая линейная структура данных), набор пар/троек элементов или подмассивы.
- целевое значение должно каким-то образом получаться из пар/троек/подмассивов или должны удаляться дубликаты.
Итоги:
- Есть ряд задач, когда при увеличении одного указателя, значение другого указателя может только уменьшаться (или наоборот увеличиваться).
  Это позволяет не перебирать каждый раз все значения, а просто продолжать с последнего.