SOLID-принципы Дяди Боба расшифровываются следующим образом:

S – Принцип единственной ответственности (Single Responsibility Principle),

O – Принцип открытости/закрытости (Open‐Closed Principle),

L – Принцип подстановки Барбары Лисков (Liskov Substitution Principle),

I – Принцип разделения интерфейсов (Interface Segregation Principle),

D – Принцип инверсии зависимостей (Dependency Inversion Principle).


S:
Принцип единственной ответственности
Принцип единой ответственности гласит, что у каждого класса должна быть только одна «ответственность» и он не должен брать на себя другие обязанности. Роберт К. Мартин объяснял его так: «У класса должна быть лишь одна причина для изменения».

Давайте в качестве примера возьмем приложение телефонного справочника.
Мы будем делать телефонный справочник, в котором будет класс TelephoneDirectory.
Он будет «нести ответственность» за ведение записей справочника, то есть телефонных номеров и названий организаций, которым принадлежат номера.
Ожидается, что класс будет выполнять следующие операции: добавлять новую запись (Name и Telephone Number), удалять существующую запись, изменять номер телефона, присвоенный сущности Name, и предоставлять поиск, который будет возвращать номер, присвоенный сущности Name.
А теперь скажем, что в проекте есть еще два требования – Сохранить содержимое справочника в базе данных и перенести содержимое справочника в файл.
Так вот, именно сейчас мы нарушили принцип единственной ответственности. Добавив функции сохранения в базу данных и сохранения в файл, мы дали классу дополнительные обязанности, которые не входят в его основную зону ответственности. Теперь в классе есть дополнительные функции, которые могут привести к его изменению. В будущем, если появятся какие-то требования, связанные с сохранением данных, это может привести к изменениям в классе TelephoneDirectory. Получается, что класс TelephoneDirectory подвержен изменениям по причинам, которые не являются его основной ответственностью.
Принцип единственной ответственности требует от нас не добавлять дополнительные обязанности к классу, чтобы нам не приходилось менять класс, когда нам нужно изменить функционал сохранения справочника в базу данных или в файл.
Мы можем передать экземпляр класса TelephoneDirectory экземплярам этих классов и записать любые дополнительные функции в них.
Так мы гарантируем, что у класса TelephoneDirectory есть лишь одна причина для изменения – это изменения в его основной «ответственности».

O:
Принцип открытости/закрытости
Принцип открытости/закрытости впервые был сформулирован Бернардом Мейером в 1988 году. Роберт К. Мартин говорил о нем так «Наиболее важный принцип открытости/закрытости гласит «Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений».

Следование этому принципу гарантирует, что класс определен достаточно, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путем создания новых сущностей, которые расширяют возможности существующего класса и добавляют дополнительные функции самим себе. Таким образом можно предотвратить частые и тривиальные изменения в хорошо зарекомендовавшем себя классе низкого уровня.

Допустим, у нас есть приложение для магазина одежды. Среди функций системы есть функция применения специальных скидок в зависимости от типа одежды.

Пример ниже показывает один из способов реализации этого требования.

В примере у нас есть класс DiscountCalculator, который умеет хранить тип одежды.
В нем есть функция, которая рассчитывает скидку в зависимости от типа одежды и возвращает новую стоимость за вычетом суммы скидки.
Эта конструкция нарушает принцип открытости/закрытости, поскольку этот класс потребует изменения, если будет добавляться какой-то тип одежды или если сумма скидки на какую-либо одежду изменится.
Как видно из примера выше, теперь у нас есть очень простой базовый класс DiscountCalculator с одним абстрактным методом get_discounted_price.
Мы создали новые классы для одежды, которые расширяют базовый класс DiscountCalculator. Следовательно, теперь каждый подкласс будет реализовывать функционал скидок самостоятельно.
Сделав так, мы устранили предыдущие ограничения, которые требовали внесения изменений в базовый класс.
Теперь, не изменяя базовый класс, мы можем добавлять больше одежды, а также изменять размер скидки на отдельный вид одежды по мере необходимости.

L:
Принцип подстановки Барбары Лисков
Принцип подстановки Лисков гласит: «Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы».
Этот принцип говорит нам о том, что если класс Sub является подтипом класса Sup, тогда в программе объекты типа Sup должны легко заменяться объектами типа Sub без необходимости изменения кода.
Лучшим варианты было бы реализовать методы setter и getter. Таким образом, мы просто получаем свойства с помощью метода setter, и его реализация остается инкапсулированной в суперклассе.

I:
Принцип разделения интерфейсов
Принцип разделения интерфейсов гласит, что «Ни один клиент не должен зависеть от методов, которые он не использует».
Принцип разделения интерфейсов предполагает создание небольших интерфейсов, известных как «ролевые интерфейсы», вместо большого интерфейса, состоящего из нескольких методов. Разделяя методы по ролям на более мелкие интерфейсы, клиенты будут зависеть только от методов, которые имеют к ним отношение.
Вместо создания большого интерфейса мы создаем более маленькие ролевые интерфейсы для каждого метода. Соответствующие классы будут использовать только связанные интерфейсы.

D:
Принцип инверсии зависимостей
Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций.

Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

Если ваш код уже реализует принципы открытости/закрытости и подстановки Лисков, он уже будет неявно согласован с принципом инверсии зависимостей.
Чтобы следовать принципу инверсии зависимостей, нам необходимо убедиться, что класс высокого уровня не зависит от конкретной реализации класса низкого уровня. Вместо этого он должен зависеть от некоторой абстракции.